/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_execution.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ewiese-m <ewiese-m@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 14:11:56 by ewiese-m          #+#    #+#             */
/*   Updated: 2025/03/31 14:41:08 by ewiese-m         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	close_other_pipes(int **pipes, int cmd_index, int cmd_count)
{
	int	i;

	printf("DEBUG: Entering close_other_pipes\n");
	i = 0;
	while (i < cmd_count - 1)
	{
		if (i != cmd_index - 1 && i != cmd_index)
		{
			printf("DEBUG: Closing pipe[%d][0] and pipe[%d][1]\n", i, i);
			close(pipes[i][0]);
			close(pipes[i][1]);
		}
		i++;
	}
	printf("DEBUG: Exiting close_other_pipes\n");
}

int	setup_redirections(t_command *cmd, int **pipes, int cmd_index, int cmd_count)
{
	printf("DEBUG: Entering setup_redirections\n");
	printf("DEBUG: cmd_index=%d, cmd_count=%d\n", cmd_index, cmd_count);
	printf("DEBUG: cmd->input=%d, cmd->output=%d\n", cmd->input, cmd->output);

	if (cmd_index > 0 && cmd->input == 0)
	{
		printf("DEBUG: Setting up input redirection from pipe\n");
		if (dup2(pipes[cmd_index - 1][0], STDIN_FILENO) == -1)
		{
			printf("DEBUG: dup2 for input failed\n");
			return (1);
		}
		printf("DEBUG: Input redirection successful\n");
	}

	if (cmd_index < cmd_count - 1 && cmd->output == 0)
	{
		printf("DEBUG: Setting up output redirection to pipe\n");
		if (dup2(pipes[cmd_index][1], STDOUT_FILENO) == -1)
		{
			printf("DEBUG: dup2 for output failed\n");
			return (1);
		}
		printf("DEBUG: Output redirection successful\n");
	}

	printf("DEBUG: Calling apply_redirections\n");
	int result = apply_redirections(cmd);
	printf("DEBUG: apply_redirections returned %d\n", result);
	printf("DEBUG: Exiting setup_redirections with return value %d\n", result);
	return (result);
}

void	execute_pipeline_command(t_pipe_exec *exec_data)
{
	char		*executable_path;
	int			status;
	t_pipeline	temp_pipeline;
	int			i;

	printf("\n--- PIPELINE COMMAND EXECUTION START ---\n");
	printf("DEBUG: Command structure pointer: %p\n", (void*)exec_data->cmd);
	printf("DEBUG: Command to execute: %s\n", exec_data->cmd->command ? exec_data->cmd->command : "NULL");
	printf("DEBUG: Command index: %d of %d\n", exec_data->cmd_index, exec_data->cmd_count);

	printf("DEBUG: Calling setup_redirections\n");
	if (setup_redirections(exec_data->cmd, exec_data->pipes,
			exec_data->cmd_index, exec_data->cmd_count) != 0)
	{
		printf("DEBUG: setup_redirections failed\n");
		temp_pipeline.pipes = exec_data->pipes;
		temp_pipeline.cmd_count = exec_data->cmd_count;
		close_all_pipes(&temp_pipeline);
		exit(1);
	}

	printf("DEBUG: setup_redirections succeeded\n");
	printf("DEBUG: Calling close_other_pipes\n");
	close_other_pipes(exec_data->pipes, exec_data->cmd_index,
		exec_data->cmd_count);
	printf("DEBUG: Returned from close_other_pipes\n");

	printf("DEBUG: Checking if command is builtin\n");
	if (is_builtin(exec_data->cmd->command))
	{
		printf("DEBUG: Command '%s' is a builtin\n", exec_data->cmd->command);
		status = execute_builtin(exec_data->cmd, exec_data->envp);
		printf("DEBUG: Builtin executed with status %d\n", status);
		exit(status);
	}
	printf("DEBUG: Command '%s' is NOT a builtin\n", exec_data->cmd->command);

	printf("DEBUG: Command structure full details:\n");
	printf("DEBUG: command=%s\n", exec_data->cmd->command ? exec_data->cmd->command : "NULL");

	if (exec_data->cmd->full_cmd)
	{
		printf("DEBUG: full_cmd array contents:\n");
		i = 0;
		while (exec_data->cmd->full_cmd[i])
		{
			printf("DEBUG: full_cmd[%d]='%s'\n", i, exec_data->cmd->full_cmd[i]);
			i++;
		}
		printf("DEBUG: full_cmd total entries: %d\n", i);
	}
	else
	{
		printf("DEBUG: full_cmd is NULL\n");
	}

	if (exec_data->cmd->args)
	{
		printf("DEBUG: args array contents:\n");
		i = 0;
		while (exec_data->cmd->args[i])
		{
			printf("DEBUG: args[%d]='%s'\n", i, exec_data->cmd->args[i]);
			i++;
		}
		printf("DEBUG: args total entries: %d\n", i);
	}
	else
	{
		printf("DEBUG: args is NULL\n");
	}

	printf("DEBUG: Calling find_executable for '%s'\n", exec_data->cmd->command);
	executable_path = find_executable(exec_data->cmd->command, exec_data->envp);

	if (!executable_path)
	{
		printf("DEBUG: find_executable returned NULL\n");
		exit(handle_command_not_found(exec_data->cmd->command));
	}

	printf("DEBUG: find_executable found path: '%s'\n", executable_path);

	// Create correct command array for execve
	char **correct_cmd;

	if (exec_data->cmd->full_cmd && exec_data->cmd->full_cmd[0])
	{
		printf("DEBUG: Using full_cmd as base for execve args\n");

		// Count elements in full_cmd
		i = 0;
		while (exec_data->cmd->full_cmd[i])
			i++;

		printf("DEBUG: full_cmd has %d elements\n", i);
		correct_cmd = malloc(sizeof(char *) * (i + 1));
		if (!correct_cmd)
		{
			printf("DEBUG: Failed to allocate memory for correct_cmd\n");
			free(executable_path);
			exit(1);
		}

		// Copy array but replace first element with full path
		correct_cmd[0] = executable_path;
		printf("DEBUG: Set correct_cmd[0]='%s'\n", executable_path);

		i = 1;
		while (exec_data->cmd->full_cmd[i])
		{
			correct_cmd[i] = exec_data->cmd->full_cmd[i];
			printf("DEBUG: Set correct_cmd[%d]='%s'\n", i, correct_cmd[i]);
			i++;
		}
		correct_cmd[i] = NULL;
		printf("DEBUG: Set correct_cmd[%d]=NULL\n", i);
	}
	else
	{
		printf("DEBUG: Building new command array from args\n");
		int arg_count = 0;

		// Count arguments
		if (exec_data->cmd->args)
		{
			while (exec_data->cmd->args[arg_count])
				arg_count++;
		}

		printf("DEBUG: Command has %d arguments\n", arg_count);

		// Allocate memory for command + args + NULL
		correct_cmd = malloc(sizeof(char *) * (arg_count + 2));
		if (!correct_cmd)
		{
			printf("DEBUG: Failed to allocate memory for correct_cmd\n");
			free(executable_path);
			exit(1);
		}

		// First element is always the full path
		correct_cmd[0] = executable_path;
		printf("DEBUG: Set correct_cmd[0]='%s'\n", executable_path);

		// Add arguments if they exist
		for (i = 0; i < arg_count; i++)
		{
			correct_cmd[i + 1] = exec_data->cmd->args[i];
			printf("DEBUG: Set correct_cmd[%d]='%s'\n", i + 1, correct_cmd[i + 1]);
		}

		// Terminate with NULL
		correct_cmd[arg_count + 1] = NULL;
		printf("DEBUG: Set correct_cmd[%d]=NULL\n", arg_count + 1);
	}

	printf("DEBUG: Final execve command array:\n");
	i = 0;
	while (correct_cmd[i])
	{
		printf("DEBUG: correct_cmd[%d]='%s'\n", i, correct_cmd[i]);
		i++;
	}

	printf("DEBUG: Calling execve with path='%s', args=%p, env=%p\n",
		executable_path, (void*)correct_cmd, (void*)exec_data->envp);
	printf("--- PIPELINE COMMAND EXECUTION END ---\n\n");

	execve(executable_path, correct_cmd, exec_data->envp);

	// If we get here, execve failed
	printf("DEBUG: execve failed: %s\n", strerror(errno));
	free(executable_path);
	free(correct_cmd);
	exit(handle_execve_error(exec_data->cmd->command));
}

int	fork_and_execute_commands(t_pipeline *pipeline, pid_t *pids, char **envp)
{
	int			i;
	t_pipe_exec	exec_data;

	printf("DEBUG: Entering fork_and_execute_commands\n");
	i = 0;
	while (i < pipeline->cmd_count)
	{
		printf("DEBUG: Forking for command %d\n", i);
		pids[i] = fork();

		if (pids[i] == -1)
		{
			printf("DEBUG: Fork failed\n");
			handle_fork_error();
			return (i);
		}
		else if (pids[i] == 0)
		{
			printf("DEBUG: In child process for command %d\n", i);
			exec_data.cmd = pipeline->commands[i];
			exec_data.pipes = pipeline->pipes;
			exec_data.cmd_index = i;
			exec_data.cmd_count = pipeline->cmd_count;
			exec_data.envp = envp;
			printf("DEBUG: Calling execute_pipeline_command\n");
			execute_pipeline_command(&exec_data);
			printf("DEBUG: This line should never be reached\n");
		}
		else
		{
			printf("DEBUG: Parent process continuing, child PID: %d\n", pids[i]);
		}
		i++;
	}
	printf("DEBUG: Exiting fork_and_execute_commands, forked %d commands\n", i);
	return (i);
}
